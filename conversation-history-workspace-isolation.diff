diff --git a/src/common.ts b/src/common.ts
index d3c537ffd..52eff5e69 100644
--- a/src/common.ts
+++ b/src/common.ts
@@ -1,10 +1,4 @@
 import * as vscode from "vscode"
-import {
-	migrateCustomInstructionsToGlobalRules,
-	migrateTaskHistoryToFile,
-	migrateWelcomeViewCompleted,
-	migrateWorkspaceToGlobalStorage,
-} from "./core/storage/state-migrations"
 import { WebviewProvider } from "./core/webview"
 import { Logger } from "./services/logging/Logger"
 import "./utils/path" // necessary to have access to String.prototype.toPosix
@@ -48,18 +42,6 @@ export async function initialize(context: vscode.ExtensionContext): Promise<Webv
 	await ErrorService.initialize()
 	await featureFlagsService.poll()
 
-	// Migrate custom instructions to global Cline rules (one-time cleanup)
-	await migrateCustomInstructionsToGlobalRules(context)
-
-	// Migrate welcomeViewCompleted setting based on existing API keys (one-time cleanup)
-	await migrateWelcomeViewCompleted(context)
-
-	// Migrate workspace storage values back to global storage (reverting previous migration)
-	await migrateWorkspaceToGlobalStorage(context)
-
-	// Ensure taskHistory.json exists and migrate legacy state (runs once)
-	await migrateTaskHistoryToFile(context)
-
 	// Clean up orphaned file context warnings (startup cleanup)
 	await FileContextTracker.cleanupOrphanedWarnings(context)
 
diff --git a/src/core/controller/index.ts b/src/core/controller/index.ts
index 8260326ce..83eb37e9f 100644
--- a/src/core/controller/index.ts
+++ b/src/core/controller/index.ts
@@ -187,12 +187,12 @@ export class Controller {
 		const terminalOutputLineLimit = this.stateManager.getGlobalSettingsKey("terminalOutputLineLimit")
 		const defaultTerminalProfile = this.stateManager.getGlobalSettingsKey("defaultTerminalProfile")
 		const isNewUser = this.stateManager.getGlobalStateKey("isNewUser")
-		const taskHistory = this.stateManager.getGlobalStateKey("taskHistory")
+		const taskHistory = this.stateManager.getWorkspaceStateKey("taskHistory") || []
 
 		const NEW_USER_TASK_COUNT_THRESHOLD = 10
 
 		// Check if the user has completed enough tasks to no longer be considered a "new user"
-		if (isNewUser && !historyItem && taskHistory && taskHistory.length >= NEW_USER_TASK_COUNT_THRESHOLD) {
+		if (isNewUser && !historyItem && taskHistory.length >= NEW_USER_TASK_COUNT_THRESHOLD) {
 			this.stateManager.setGlobalState("isNewUser", false)
 			await this.postStateToWebview()
 		}
@@ -626,7 +626,7 @@ export class Controller {
 		taskMetadataFilePath: string
 		apiConversationHistory: Anthropic.MessageParam[]
 	}> {
-		const history = this.stateManager.getGlobalStateKey("taskHistory")
+		const history = this.stateManager.getWorkspaceStateKey("taskHistory") || []
 		const historyItem = history.find((item) => item.id === id)
 		if (historyItem) {
 			const taskDirPath = path.join(HostProvider.get().globalStorageFsPath, "tasks", id)
@@ -661,9 +661,9 @@ export class Controller {
 
 	async deleteTaskFromState(id: string) {
 		// Remove the task from history
-		const taskHistory = this.stateManager.getGlobalStateKey("taskHistory")
+		const taskHistory = this.stateManager.getWorkspaceStateKey("taskHistory") || []
 		const updatedTaskHistory = taskHistory.filter((task) => task.id !== id)
-		this.stateManager.setGlobalState("taskHistory", updatedTaskHistory)
+		this.stateManager.setWorkspaceState("taskHistory", updatedTaskHistory)
 
 		// Notify the webview that the task has been deleted
 		await this.postStateToWebview()
@@ -680,7 +680,7 @@ export class Controller {
 		// Get API configuration from cache for immediate access
 		const apiConfiguration = this.stateManager.getApiConfiguration()
 		const lastShownAnnouncementId = this.stateManager.getGlobalStateKey("lastShownAnnouncementId")
-		const taskHistory = this.stateManager.getGlobalStateKey("taskHistory")
+		const taskHistory = this.stateManager.getWorkspaceStateKey("taskHistory") || []
 		const autoApprovalSettings = this.stateManager.getGlobalSettingsKey("autoApprovalSettings")
 		const browserSettings = this.stateManager.getGlobalSettingsKey("browserSettings")
 		const focusChainSettings = this.stateManager.getGlobalSettingsKey("focusChainSettings")
@@ -824,14 +824,14 @@ export class Controller {
 	*/
 
 	async updateTaskHistory(item: HistoryItem): Promise<HistoryItem[]> {
-		const history = this.stateManager.getGlobalStateKey("taskHistory")
+		const history = this.stateManager.getWorkspaceStateKey("taskHistory") || []
 		const existingItemIndex = history.findIndex((h) => h.id === item.id)
 		if (existingItemIndex !== -1) {
 			history[existingItemIndex] = item
 		} else {
 			history.push(item)
 		}
-		this.stateManager.setGlobalState("taskHistory", history)
+		this.stateManager.setWorkspaceState("taskHistory", history)
 		return history
 	}
 }
diff --git a/src/core/controller/task/deleteAllTaskHistory.ts b/src/core/controller/task/deleteAllTaskHistory.ts
index e54ad7083..d4fed1335 100644
--- a/src/core/controller/task/deleteAllTaskHistory.ts
+++ b/src/core/controller/task/deleteAllTaskHistory.ts
@@ -18,7 +18,7 @@ export async function deleteAllTaskHistory(controller: Controller): Promise<Dele
 		await controller.clearTask()
 
 		// Get existing task history
-		const taskHistory = controller.stateManager.getGlobalStateKey("taskHistory")
+		const taskHistory = controller.stateManager.getWorkspaceStateKey("taskHistory") || []
 		const totalTasks = taskHistory.length
 
 		const userChoice = (
@@ -47,7 +47,7 @@ export async function deleteAllTaskHistory(controller: Controller): Promise<Dele
 
 			// If there are favorited tasks, update state
 			if (favoritedTasks.length > 0) {
-				controller.stateManager.setGlobalState("taskHistory", favoritedTasks)
+				controller.stateManager.setWorkspaceState("taskHistory", favoritedTasks)
 
 				// Delete non-favorited task directories
 				const preserveTaskIds = favoritedTasks.map((task) => task.id)
@@ -87,7 +87,7 @@ export async function deleteAllTaskHistory(controller: Controller): Promise<Dele
 		}
 
 		// Delete everything (not preserving favorites)
-		controller.stateManager.setGlobalState("taskHistory", [])
+		controller.stateManager.setWorkspaceState("taskHistory", [])
 
 		try {
 			// Remove all contents of tasks directory
diff --git a/src/core/controller/task/getTaskHistory.ts b/src/core/controller/task/getTaskHistory.ts
index 560f55fe1..84fed429a 100644
--- a/src/core/controller/task/getTaskHistory.ts
+++ b/src/core/controller/task/getTaskHistory.ts
@@ -1,5 +1,6 @@
 import { GetTaskHistoryRequest, TaskHistoryArray } from "@shared/proto/cline/task"
 import { arePathsEqual, getWorkspacePath } from "../../../utils/path"
+import { readTaskHistoryFromState } from "../../storage/disk"
 import { Controller } from ".."
 
 /**
@@ -12,8 +13,16 @@ export async function getTaskHistory(controller: Controller, request: GetTaskHis
 	try {
 		const { favoritesOnly, currentWorkspaceOnly, searchQuery, sortBy } = request
 
-		// Get task history from global state
-		const taskHistory = controller.stateManager.getGlobalStateKey("taskHistory")
+		// Get task history - from workspace state if filtering by current workspace,
+		// otherwise from global aggregated history to support cross-workspace view
+		let taskHistory
+		if (currentWorkspaceOnly) {
+			// Only show current workspace tasks
+			taskHistory = controller.stateManager.getWorkspaceStateKey("taskHistory") || []
+		} else {
+			// Show all workspaces - read from global aggregated history
+			taskHistory = await readTaskHistoryFromState()
+		}
 		const workspacePath = await getWorkspacePath()
 
 		// Apply filters
diff --git a/src/core/controller/task/showTaskWithId.ts b/src/core/controller/task/showTaskWithId.ts
index eb5c2da96..782e1fc79 100644
--- a/src/core/controller/task/showTaskWithId.ts
+++ b/src/core/controller/task/showTaskWithId.ts
@@ -14,7 +14,7 @@ export async function showTaskWithId(controller: Controller, request: StringRequ
 		const id = request.value
 
 		// First check if task exists in global state for faster access
-		const taskHistory = controller.stateManager.getGlobalStateKey("taskHistory")
+		const taskHistory = controller.stateManager.getWorkspaceStateKey("taskHistory") || []
 		const historyItem = taskHistory.find((item) => item.id === id)
 
 		// We need to initialize the task before returning data
diff --git a/src/core/controller/task/toggleTaskFavorite.ts b/src/core/controller/task/toggleTaskFavorite.ts
index c3714a60a..fb28f59b5 100644
--- a/src/core/controller/task/toggleTaskFavorite.ts
+++ b/src/core/controller/task/toggleTaskFavorite.ts
@@ -12,7 +12,7 @@ export async function toggleTaskFavorite(controller: Controller, request: TaskFa
 	try {
 		// Update in-memory state only
 		try {
-			const history = controller.stateManager.getGlobalStateKey("taskHistory")
+			const history = controller.stateManager.getWorkspaceStateKey("taskHistory") || []
 
 			const taskIndex = history.findIndex((item) => item.id === request.taskId)
 
@@ -28,9 +28,9 @@ export async function toggleTaskFavorite(controller: Controller, request: TaskFa
 
 				// Update global state and wait for it to complete
 				try {
-					controller.stateManager.setGlobalState("taskHistory", updatedHistory)
+					controller.stateManager.setWorkspaceState("taskHistory", updatedHistory)
 				} catch (stateErr) {
-					console.error("Error updating global state:", stateErr)
+					console.error("Error updating workspace state:", stateErr)
 				}
 			}
 		} catch (historyErr) {
diff --git a/src/core/storage/StateManager.ts b/src/core/storage/StateManager.ts
index b963fdc64..b904cf08a 100644
--- a/src/core/storage/StateManager.ts
+++ b/src/core/storage/StateManager.ts
@@ -1,15 +1,8 @@
 import { ApiConfiguration } from "@shared/api"
-import chokidar, { FSWatcher } from "chokidar"
 import type { ExtensionContext } from "vscode"
 import { HostProvider } from "@/hosts/host-provider"
 import { ShowMessageType } from "@/shared/proto/index.host"
-import {
-	getTaskHistoryStateFilePath,
-	readTaskHistoryFromState,
-	readTaskSettingsFromStorage,
-	writeTaskHistoryToState,
-	writeTaskSettingsToStorage,
-} from "./disk"
+import { readTaskSettingsFromStorage, writeTaskSettingsToStorage } from "./disk"
 import { STATE_MANAGER_NOT_INITIALIZED } from "./error-messages"
 import {
 	GlobalState,
@@ -49,7 +42,6 @@ export class StateManager {
 	private pendingWorkspaceState = new Set<LocalStateKey>()
 	private persistenceTimeout: NodeJS.Timeout | null = null
 	private readonly PERSISTENCE_DELAY_MS = 500
-	private taskHistoryWatcher: FSWatcher | null = null
 
 	// Callback for persistence errors
 	onPersistenceError?: (event: PersistenceErrorEvent) => void
@@ -83,9 +75,6 @@ export class StateManager {
 			// Use populate method to avoid triggering persistence during initialization
 			StateManager.instance.populateCache(globalState, secrets, workspaceState)
 
-			// Start watcher for taskHistory.json so external edits update cache (no persist loop)
-			await StateManager.instance.setupTaskHistoryWatcher()
-
 			StateManager.instance.isInitialized = true
 		} catch (error) {
 			console.error("[StateManager] Failed to initialize:", error)
@@ -299,9 +288,12 @@ export class StateManager {
 			throw new Error(STATE_MANAGER_NOT_INITIALIZED)
 		}
 
-		// Update cache immediately for all keys
-		Object.entries(updates).forEach(([key, value]) => {
-			this.workspaceStateCache[key as keyof LocalState] = value
+		// Update cache in one go
+		// Using object.assign to because typescript is not able to infer the type of the updates object when using Object.entries
+		Object.assign(this.workspaceStateCache, updates)
+
+		// Then track the keys for persistence
+		Object.keys(updates).forEach((key) => {
 			this.pendingWorkspaceState.add(key as LocalStateKey)
 		})
 
@@ -309,56 +301,6 @@ export class StateManager {
 		this.scheduleDebouncedPersistence()
 	}
 
-	/**
-	 * Initialize chokidar watcher for the taskHistory.json file
-	 * Updates in-memory cache on external changes without writing back to disk.
-	 */
-	private async setupTaskHistoryWatcher(): Promise<void> {
-		try {
-			const historyFile = await getTaskHistoryStateFilePath()
-
-			// Close any existing watcher before creating a new one
-			if (this.taskHistoryWatcher) {
-				await this.taskHistoryWatcher.close()
-				this.taskHistoryWatcher = null
-			}
-
-			this.taskHistoryWatcher = chokidar.watch(historyFile, {
-				persistent: true,
-				ignoreInitial: true,
-				atomic: true,
-				awaitWriteFinish: { stabilityThreshold: 300, pollInterval: 100 },
-			})
-
-			const syncTaskHistoryFromDisk = async () => {
-				try {
-					if (!this.isInitialized) {
-						return
-					}
-					const onDisk = await readTaskHistoryFromState()
-					const cached = this.globalStateCache["taskHistory"]
-					if (JSON.stringify(onDisk) !== JSON.stringify(cached)) {
-						this.globalStateCache["taskHistory"] = onDisk
-						await this.onSyncExternalChange?.()
-					}
-				} catch (err) {
-					console.error("[StateManager] Failed to reload task history on change:", err)
-				}
-			}
-
-			this.taskHistoryWatcher
-				.on("add", () => syncTaskHistoryFromDisk())
-				.on("change", () => syncTaskHistoryFromDisk())
-				.on("unlink", async () => {
-					this.globalStateCache["taskHistory"] = []
-					await this.onSyncExternalChange?.()
-				})
-				.on("error", (error) => console.error("[StateManager] TaskHistory watcher error:", error))
-		} catch (err) {
-			console.error("[StateManager] Failed to set up taskHistory watcher:", err)
-		}
-	}
-
 	/**
 	 * Convenience method for getting API configuration
 	 * Ensures cache is initialized if not already done
@@ -741,11 +683,6 @@ export class StateManager {
 			clearTimeout(this.persistenceTimeout)
 			this.persistenceTimeout = null
 		}
-		// Close file watcher if active
-		if (this.taskHistoryWatcher) {
-			this.taskHistoryWatcher.close()
-			this.taskHistoryWatcher = null
-		}
 
 		this.pendingGlobalState.clear()
 		this.pendingSecrets.clear()
@@ -800,15 +737,8 @@ export class StateManager {
 	 */
 	private async persistGlobalStateBatch(keys: Set<GlobalStateAndSettingsKey>): Promise<void> {
 		try {
-			await Promise.all(
-				Array.from(keys).map((key) => {
-					if (key === "taskHistory") {
-						// Route task history persistence to file, not VS Code globalState
-						return writeTaskHistoryToState(this.globalStateCache[key])
-					}
-					return this.context.globalState.update(key, this.globalStateCache[key])
-				}),
-			)
+			// taskHistory now in LocalState, no special handling needed
+			await Promise.all(Array.from(keys).map((key) => this.context.globalState.update(key, this.globalStateCache[key])))
 		} catch (error) {
 			console.error("[StateManager] Failed to persist global state batch:", error)
 			throw error
diff --git a/src/core/storage/disk.ts b/src/core/storage/disk.ts
index 4acdbc4a2..f9756996c 100644
--- a/src/core/storage/disk.ts
+++ b/src/core/storage/disk.ts
@@ -4,6 +4,7 @@ import { execa } from "@packages/execa"
 import { ClineMessage } from "@shared/ExtensionMessage"
 import { HistoryItem } from "@shared/HistoryItem"
 import { fileExistsAtPath } from "@utils/fs"
+import { randomUUID } from "crypto"
 import fs from "fs/promises"
 import os from "os"
 import * as path from "path"
@@ -27,6 +28,26 @@ export const GlobalFileNames = {
 	taskMetadata: "task_metadata.json",
 }
 
+/**
+ * Atomic write: Write to temp file, then rename
+ * Prevents corruption from partial writes and concurrent access
+ */
+async function atomicWriteFile(filePath: string, content: string): Promise<void> {
+	const tempPath = `${filePath}.${randomUUID()}.tmp`
+	try {
+		// Write to temp file
+		await fs.writeFile(tempPath, content, "utf8")
+		// Atomic rename (overwrites target if exists)
+		await fs.rename(tempPath, filePath)
+	} catch (error) {
+		// Clean up temp file if it exists
+		try {
+			await fs.unlink(tempPath)
+		} catch {}
+		throw error
+	}
+}
+
 export async function getDocumentsPath(): Promise<string> {
 	if (process.platform === "win32") {
 		try {
@@ -116,7 +137,7 @@ export async function getSavedApiConversationHistory(taskId: string): Promise<An
 export async function saveApiConversationHistory(taskId: string, apiConversationHistory: Anthropic.MessageParam[]) {
 	try {
 		const filePath = path.join(await ensureTaskDirectoryExists(taskId), GlobalFileNames.apiConversationHistory)
-		await fs.writeFile(filePath, JSON.stringify(apiConversationHistory))
+		await atomicWriteFile(filePath, JSON.stringify(apiConversationHistory))
 	} catch (error) {
 		// in the off chance this fails, we don't want to stop the task
 		console.error("Failed to save API conversation history:", error)
@@ -143,7 +164,7 @@ export async function saveClineMessages(taskId: string, uiMessages: ClineMessage
 	try {
 		const taskDir = await ensureTaskDirectoryExists(taskId)
 		const filePath = path.join(taskDir, GlobalFileNames.uiMessages)
-		await fs.writeFile(filePath, JSON.stringify(uiMessages))
+		await atomicWriteFile(filePath, JSON.stringify(uiMessages))
 	} catch (error) {
 		console.error("Failed to save ui messages:", error)
 	}
@@ -165,7 +186,7 @@ export async function saveTaskMetadata(taskId: string, metadata: TaskMetadata) {
 	try {
 		const taskDir = await ensureTaskDirectoryExists(taskId)
 		const filePath = path.join(taskDir, GlobalFileNames.taskMetadata)
-		await fs.writeFile(filePath, JSON.stringify(metadata, null, 2))
+		await atomicWriteFile(filePath, JSON.stringify(metadata, null, 2))
 	} catch (error) {
 		console.error("Failed to save task metadata:", error)
 	}
@@ -254,7 +275,7 @@ export async function writeTaskSettingsToStorage(taskId: string, settings: Parti
 		}
 
 		const updatedSettings = { ...existingSettings, ...settings }
-		await fs.writeFile(settingsFilePath, JSON.stringify(updatedSettings, null, 2))
+		await atomicWriteFile(settingsFilePath, JSON.stringify(updatedSettings, null, 2))
 	} catch (error) {
 		console.error("[Disk] Failed to write task settings:", error)
 		throw error
diff --git a/src/core/storage/state-keys.ts b/src/core/storage/state-keys.ts
index 992100302..982cc7b99 100644
--- a/src/core/storage/state-keys.ts
+++ b/src/core/storage/state-keys.ts
@@ -26,7 +26,7 @@ export type GlobalStateAndSettings = GlobalState & Settings
 
 export interface GlobalState {
 	lastShownAnnouncementId: string | undefined
-	taskHistory: HistoryItem[]
+	// taskHistory moved to LocalState for workspace isolation
 	userInfo: UserInfo | undefined
 	mcpMarketplaceCatalog: McpMarketplaceCatalog | undefined
 	favoritedModelIds: string[]
@@ -214,6 +214,7 @@ export interface Secrets {
 }
 
 export interface LocalState {
+	taskHistory: HistoryItem[] // Workspace-specific task history for proper isolation
 	localClineRulesToggles: ClineRulesToggles
 	localCursorRulesToggles: ClineRulesToggles
 	localWindsurfRulesToggles: ClineRulesToggles
diff --git a/src/core/storage/state-migrations.ts b/src/core/storage/state-migrations.ts
index 53e080e5f..12e3bc77a 100644
--- a/src/core/storage/state-migrations.ts
+++ b/src/core/storage/state-migrations.ts
@@ -1,640 +1,225 @@
+/**
+ * State migrations for Cline extension
+ * Handles migration of data structures between versions
+ */
+
+import { HistoryItem } from "@shared/HistoryItem"
 import fs from "fs/promises"
 import path from "path"
-import * as vscode from "vscode"
-import { HistoryItem } from "@/shared/HistoryItem"
-import { ensureRulesDirectoryExists, readTaskHistoryFromState, writeTaskHistoryToState } from "./disk"
-
-export async function migrateWorkspaceToGlobalStorage(context: vscode.ExtensionContext) {
-	// Keys to migrate from workspace storage back to global storage
-	const keysToMigrate = [
-		// Core settings
-		"apiProvider",
-		"apiModelId",
-		"thinkingBudgetTokens",
-		"reasoningEffort",
-		"vsCodeLmModelSelector",
-
-		// Provider-specific model keys
-		"awsBedrockCustomSelected",
-		"awsBedrockCustomModelBaseId",
-		"openRouterModelId",
-		"openRouterModelInfo",
-		"openAiModelId",
-		"openAiModelInfo",
-		"ollamaModelId",
-		"lmStudioModelId",
-		"liteLlmModelId",
-		"liteLlmModelInfo",
-		"requestyModelId",
-		"requestyModelInfo",
-		"togetherModelId",
-		"fireworksModelId",
-		"sapAiCoreModelId",
-		"groqModelId",
-		"groqModelInfo",
-		"huggingFaceModelId",
-		"huggingFaceModelInfo",
-
-		// Previous mode settings
-		"previousModeApiProvider",
-		"previousModeModelId",
-		"previousModeModelInfo",
-		"previousModeVsCodeLmModelSelector",
-		"previousModeThinkingBudgetTokens",
-		"previousModeReasoningEffort",
-		"previousModeAwsBedrockCustomSelected",
-		"previousModeAwsBedrockCustomModelBaseId",
-		"previousModeSapAiCoreModelId",
-	]
-
-	for (const key of keysToMigrate) {
-		// Use raw workspace state since these keys shouldn't be in workspace storage
-		const workspaceValue = await context.workspaceState.get(key)
-		const globalValue = await context.globalState.get(key)
-
-		if (workspaceValue !== undefined && globalValue === undefined) {
-			console.log(`[Storage Migration] migrating key: ${key} to global storage. Current value: ${workspaceValue}`)
-
-			// Move to global storage using raw VSCode method to avoid type errors
-			await context.globalState.update(key, workspaceValue)
-			// Remove from workspace storage
-			await context.workspaceState.update(key, undefined)
-			const newWorkspaceValue = await context.workspaceState.get(key)
-
-			console.log(`[Storage Migration] migrated key: ${key} to global storage. Current value: ${newWorkspaceValue}`)
+import { ExtensionContext } from "vscode"
+import { getTaskHistoryStateFilePath, readTaskHistoryFromState, taskHistoryStateFileExists } from "./disk"
+
+const MIGRATION_VERSION_KEY = "taskHistoryMigrationVersion"
+const CURRENT_MIGRATION_VERSION = 1
+
+/**
+ * Validate that task history data is well-formed
+ */
+function validateTaskHistory(data: any[]): boolean {
+	if (!Array.isArray(data)) {
+		return false
+	}
+
+	// Check if each item has required fields
+	for (const item of data) {
+		if (!item.id || !item.ts || typeof item.ts !== "number") {
+			return false
 		}
 	}
+
+	return true
 }
 
-export async function migrateTaskHistoryToFile(context: vscode.ExtensionContext) {
+/**
+ * Create a backup of the taskHistory file before migration
+ */
+async function backupTaskHistoryFile(): Promise<string | null> {
 	try {
-		// Get data from old location
-		const vscodeGlobalStateTaskHistory = context.globalState.get<HistoryItem[] | undefined>("taskHistory")
+		const originalPath = await getTaskHistoryStateFilePath()
+		const timestamp = new Date().toISOString().replace(/:/g, "-").replace(/\..+/, "")
+		const backupPath = `${originalPath}.backup-${timestamp}`
 
-		// Normalize old location data to array (empty array if undefined/null/not-array)
-		const oldLocationData = Array.isArray(vscodeGlobalStateTaskHistory) ? vscodeGlobalStateTaskHistory : []
-
-		// Early return if no migration needed
-		if (oldLocationData.length === 0) {
-			console.log("[Storage Migration] No task history to migrate")
-			return
-		}
+		await fs.copyFile(originalPath, backupPath)
+		console.log(`[Migration] Created backup at: ${backupPath}`)
+		return backupPath
+	} catch (error) {
+		console.error("[Migration] Failed to create backup:", error)
+		return null
+	}
+}
 
-		let finalData: HistoryItem[]
-		let migrationAction: string
+/**
+ * Pre-check: Validate migration can proceed safely
+ */
+async function performPreMigrationCheck(context: ExtensionContext): Promise<{
+	canProceed: boolean
+	oldFileExists: boolean
+	oldTaskHistory: HistoryItem[]
+	validationErrors: string[]
+}> {
+	const result = {
+		canProceed: false,
+		oldFileExists: false,
+		oldTaskHistory: [] as HistoryItem[],
+		validationErrors: [] as string[],
+	}
 
-		const newLocationData = await readTaskHistoryFromState()
+	try {
+		// Check if old file exists
+		result.oldFileExists = await taskHistoryStateFileExists()
 
-		if (newLocationData.length === 0) {
-			// Move old data to new location
-			finalData = oldLocationData
-			migrationAction = "Migrated task history from old location to new location"
-		} else {
-			// Merge old data (more recent) with new data
-			finalData = [...newLocationData, ...oldLocationData]
-			migrationAction = "Merged task history from old and new locations"
+		if (!result.oldFileExists) {
+			result.canProceed = true // No data to migrate, safe to proceed
+			return result
 		}
 
-		// Perform migration operations sequentially - only clear old data if write succeeds
-		await writeTaskHistoryToState(finalData)
-
-		const successfullyWrittenData = await readTaskHistoryFromState()
+		// Read and validate old data
+		const oldData = await readTaskHistoryFromState()
 
-		if (!Array.isArray(successfullyWrittenData)) {
-			console.error("[Storage Migration] Failed to write taskHistory to file: Written data is not an array")
-			return
+		if (!validateTaskHistory(oldData)) {
+			result.validationErrors.push("Old taskHistory file contains invalid data structure")
+			return result
 		}
 
-		if (successfullyWrittenData.length !== finalData.length) {
-			console.error(
-				"[Storage Migration] Failed to write taskHistory to file: Written data does not match the old location data",
-			)
-			return
-		}
+		result.oldTaskHistory = oldData
 
-		await context.globalState.update("taskHistory", undefined)
+		// Validate workspace state is accessible
+		try {
+			const testValue = context.workspaceState.get<any>("__migration_test__")
+			await context.workspaceState.update("__migration_test__", null)
+		} catch (error) {
+			result.validationErrors.push(`Workspace state is not accessible: ${error}`)
+			return result
+		}
 
-		console.log(`[Storage Migration] ${migrationAction}`)
+		// All checks passed
+		result.canProceed = true
+		return result
 	} catch (error) {
-		console.error("[Storage Migration] Failed to migrate task history to file:", error)
+		result.validationErrors.push(`Pre-check failed: ${error}`)
+		return result
 	}
 }
 
-export async function migrateMcpMarketplaceEnableSetting(mcpMarketplaceEnabledRaw: boolean | undefined): Promise<boolean> {
-	const config = vscode.workspace.getConfiguration("cline")
-	const mcpMarketplaceEnabled = config.get<boolean>("mcpMarketplace.enabled")
-	if (mcpMarketplaceEnabled !== undefined) {
-		// Remove from VSCode configuration
-		await config.update("mcpMarketplace.enabled", undefined, true)
-
-		return !mcpMarketplaceEnabled
+/**
+ * Migrate taskHistory from global file-based storage to VSCode workspace state
+ * This fixes the conversation history loss issue by properly isolating task history per workspace
+ *
+ * Includes:
+ * - Pre-migration validation
+ * - Automatic backup before migration
+ * - Safe merge strategy (no data loss)
+ * - Idempotent (safe to re-run)
+ * - Comprehensive error handling
+ *
+ * @param context VSCode extension context
+ */
+export async function migrateTaskHistoryToWorkspaceState(context: ExtensionContext): Promise<void> {
+	const migrationVersion = context.globalState.get<number>(MIGRATION_VERSION_KEY, 0)
+
+	if (migrationVersion >= CURRENT_MIGRATION_VERSION) {
+		// Already migrated
+		console.log("[Migration] taskHistory migration already completed (v" + migrationVersion + ")")
+		return
 	}
-	return mcpMarketplaceEnabledRaw ?? true
-}
 
-export async function migrateEnableCheckpointsSetting(enableCheckpointsSettingRaw: boolean | undefined): Promise<boolean> {
-	const config = vscode.workspace.getConfiguration("cline")
-	const enableCheckpoints = config.get<boolean>("enableCheckpoints")
-	if (enableCheckpoints !== undefined) {
-		// Remove from VSCode configuration
-		await config.update("enableCheckpoints", undefined, true)
-		return enableCheckpoints
-	}
-	return enableCheckpointsSettingRaw ?? true
-}
+	console.log("[Migration] Starting taskHistory migration to workspace state...")
+	console.log("[Migration] Current migration version: " + migrationVersion)
+	console.log("[Migration] Target migration version: " + CURRENT_MIGRATION_VERSION)
 
-export async function migrateCustomInstructionsToGlobalRules(context: vscode.ExtensionContext) {
 	try {
-		const customInstructions = (await context.globalState.get("customInstructions")) as string | undefined
-
-		if (customInstructions?.trim()) {
-			console.log("Migrating custom instructions to global Cline rules...")
-
-			// Create global .clinerules directory if it doesn't exist
-			const globalRulesDir = await ensureRulesDirectoryExists()
-
-			// Use a fixed filename for custom instructions
-			const migrationFileName = "custom_instructions.md"
-			const migrationFilePath = path.join(globalRulesDir, migrationFileName)
-
-			try {
-				// Check if file already exists to determine if we should append
-				let existingContent = ""
-				try {
-					existingContent = await fs.readFile(migrationFilePath, "utf8")
-				} catch (_readError) {
-					// File doesn't exist, which is fine
-				}
-
-				// Append or create the file with custom instructions
-				const contentToWrite = existingContent
-					? `${existingContent}\n\n---\n\n${customInstructions.trim()}`
-					: customInstructions.trim()
-
-				await fs.writeFile(migrationFilePath, contentToWrite)
-				console.log(`Successfully ${existingContent ? "appended to" : "created"} migration file: ${migrationFilePath}`)
-			} catch (fileError) {
-				console.error("Failed to write migration file:", fileError)
-				return
-			}
+		// Step 1: Pre-migration check
+		console.log("[Migration] Step 1: Running pre-migration checks...")
+		const preCheck = await performPreMigrationCheck(context)
+
+		if (!preCheck.canProceed) {
+			console.error("[Migration] Pre-migration check failed:", preCheck.validationErrors)
+			console.error("[Migration] Migration aborted. Extension will continue with current state.")
+			// Don't mark as migrated so we can try again later
+			return
+		}
 
-			// Remove customInstructions from global state only after successful file creation
-			await context.globalState.update("customInstructions", undefined)
-			console.log("Successfully migrated custom instructions to global Cline rules")
+		if (!preCheck.oldFileExists) {
+			// No old data to migrate, mark as complete
+			await context.globalState.update(MIGRATION_VERSION_KEY, CURRENT_MIGRATION_VERSION)
+			console.log("[Migration] No old taskHistory file found, migration complete")
+			return
 		}
-	} catch (error) {
-		console.error("Failed to migrate custom instructions to global rules:", error)
-		// Continue execution - migration failure shouldn't break extension startup
-	}
-}
 
-export async function migrateLegacyApiConfigurationToModeSpecific(context: vscode.ExtensionContext) {
-	try {
-		// Check if migration is needed - if planModeApiProvider already exists, skip migration
-		const planModeApiProvider = await context.globalState.get("planModeApiProvider")
-		if (planModeApiProvider !== undefined) {
-			console.log("Legacy API configuration migration already completed, skipping...")
+		const oldTaskHistory = preCheck.oldTaskHistory
+
+		if (oldTaskHistory.length === 0) {
+			// Empty history, nothing to migrate
+			await context.globalState.update(MIGRATION_VERSION_KEY, CURRENT_MIGRATION_VERSION)
+			console.log("[Migration] Old taskHistory was empty, migration complete")
 			return
 		}
 
-		console.log("Starting legacy API configuration migration to mode-specific keys...")
-
-		// Get the planActSeparateModelsSetting to determine migration strategy
-		const planActSeparateModelsSetting = (await context.globalState.get("planActSeparateModelsSetting")) as
-			| boolean
-			| undefined
-
-		// Read legacy values directly
-		const apiProvider = await context.globalState.get("apiProvider")
-		const apiModelId = await context.globalState.get("apiModelId")
-		const thinkingBudgetTokens = await context.globalState.get("thinkingBudgetTokens")
-		const reasoningEffort = await context.globalState.get("reasoningEffort")
-		const vsCodeLmModelSelector = await context.globalState.get("vsCodeLmModelSelector")
-		const awsBedrockCustomSelected = await context.globalState.get("awsBedrockCustomSelected")
-		const awsBedrockCustomModelBaseId = await context.globalState.get("awsBedrockCustomModelBaseId")
-		const openRouterModelId = await context.globalState.get("openRouterModelId")
-		const openRouterModelInfo = await context.globalState.get("openRouterModelInfo")
-		const openAiModelId = await context.globalState.get("openAiModelId")
-		const openAiModelInfo = await context.globalState.get("openAiModelInfo")
-		const ollamaModelId = await context.globalState.get("ollamaModelId")
-		const lmStudioModelId = await context.globalState.get("lmStudioModelId")
-		const liteLlmModelId = await context.globalState.get("liteLlmModelId")
-		const liteLlmModelInfo = await context.globalState.get("liteLlmModelInfo")
-		const requestyModelId = await context.globalState.get("requestyModelId")
-		const requestyModelInfo = await context.globalState.get("requestyModelInfo")
-		const togetherModelId = await context.globalState.get("togetherModelId")
-		const fireworksModelId = await context.globalState.get("fireworksModelId")
-		const sapAiCoreModelId = await context.globalState.get("sapAiCoreModelId")
-		const groqModelId = await context.globalState.get("groqModelId")
-		const groqModelInfo = await context.globalState.get("groqModelInfo")
-		const huggingFaceModelId = await context.globalState.get("huggingFaceModelId")
-		const huggingFaceModelInfo = await context.globalState.get("huggingFaceModelInfo")
-
-		// Read previous mode values
-		const previousModeApiProvider = await context.globalState.get("previousModeApiProvider")
-		const previousModeModelId = await context.globalState.get("previousModeModelId")
-		const previousModeModelInfo = await context.globalState.get("previousModeModelInfo")
-		const previousModeVsCodeLmModelSelector = await context.globalState.get("previousModeVsCodeLmModelSelector")
-		const previousModeThinkingBudgetTokens = await context.globalState.get("previousModeThinkingBudgetTokens")
-		const previousModeReasoningEffort = await context.globalState.get("previousModeReasoningEffort")
-		const previousModeAwsBedrockCustomSelected = await context.globalState.get("previousModeAwsBedrockCustomSelected")
-		const previousModeAwsBedrockCustomModelBaseId = await context.globalState.get("previousModeAwsBedrockCustomModelBaseId")
-		const previousModeSapAiCoreModelId = await context.globalState.get("previousModeSapAiCoreModelId")
-
-		// Migrate based on planActSeparateModelsSetting
-		if (planActSeparateModelsSetting === false) {
-			console.log("Migrating with separate models DISABLED - using current values for both modes")
-
-			// Use current values for both plan and act modes
-			if (apiProvider !== undefined) {
-				await context.globalState.update("planModeApiProvider", apiProvider)
-				await context.globalState.update("actModeApiProvider", apiProvider)
-			}
-			if (apiModelId !== undefined) {
-				await context.globalState.update("planModeApiModelId", apiModelId)
-				await context.globalState.update("actModeApiModelId", apiModelId)
-			}
-			if (thinkingBudgetTokens !== undefined) {
-				await context.globalState.update("planModeThinkingBudgetTokens", thinkingBudgetTokens)
-				await context.globalState.update("actModeThinkingBudgetTokens", thinkingBudgetTokens)
-			}
-			if (reasoningEffort !== undefined) {
-				await context.globalState.update("planModeReasoningEffort", reasoningEffort)
-				await context.globalState.update("actModeReasoningEffort", reasoningEffort)
-			}
-			if (vsCodeLmModelSelector !== undefined) {
-				await context.globalState.update("planModeVsCodeLmModelSelector", vsCodeLmModelSelector)
-				await context.globalState.update("actModeVsCodeLmModelSelector", vsCodeLmModelSelector)
-			}
-			if (awsBedrockCustomSelected !== undefined) {
-				await context.globalState.update("planModeAwsBedrockCustomSelected", awsBedrockCustomSelected)
-				await context.globalState.update("actModeAwsBedrockCustomSelected", awsBedrockCustomSelected)
-			}
-			if (awsBedrockCustomModelBaseId !== undefined) {
-				await context.globalState.update("planModeAwsBedrockCustomModelBaseId", awsBedrockCustomModelBaseId)
-				await context.globalState.update("actModeAwsBedrockCustomModelBaseId", awsBedrockCustomModelBaseId)
-			}
-			if (openRouterModelId !== undefined) {
-				await context.globalState.update("planModeOpenRouterModelId", openRouterModelId)
-				await context.globalState.update("actModeOpenRouterModelId", openRouterModelId)
-			}
-			if (openRouterModelInfo !== undefined) {
-				await context.globalState.update("planModeOpenRouterModelInfo", openRouterModelInfo)
-				await context.globalState.update("actModeOpenRouterModelInfo", openRouterModelInfo)
-			}
-			if (openAiModelId !== undefined) {
-				await context.globalState.update("planModeOpenAiModelId", openAiModelId)
-				await context.globalState.update("actModeOpenAiModelId", openAiModelId)
-			}
-			if (openAiModelInfo !== undefined) {
-				await context.globalState.update("planModeOpenAiModelInfo", openAiModelInfo)
-				await context.globalState.update("actModeOpenAiModelInfo", openAiModelInfo)
-			}
-			if (ollamaModelId !== undefined) {
-				await context.globalState.update("planModeOllamaModelId", ollamaModelId)
-				await context.globalState.update("actModeOllamaModelId", ollamaModelId)
-			}
-			if (lmStudioModelId !== undefined) {
-				await context.globalState.update("planModeLmStudioModelId", lmStudioModelId)
-				await context.globalState.update("actModeLmStudioModelId", lmStudioModelId)
-			}
-			if (liteLlmModelId !== undefined) {
-				await context.globalState.update("planModeLiteLlmModelId", liteLlmModelId)
-				await context.globalState.update("actModeLiteLlmModelId", liteLlmModelId)
-			}
-			if (liteLlmModelInfo !== undefined) {
-				await context.globalState.update("planModeLiteLlmModelInfo", liteLlmModelInfo)
-				await context.globalState.update("actModeLiteLlmModelInfo", liteLlmModelInfo)
-			}
-			if (requestyModelId !== undefined) {
-				await context.globalState.update("planModeRequestyModelId", requestyModelId)
-				await context.globalState.update("actModeRequestyModelId", requestyModelId)
-			}
-			if (requestyModelInfo !== undefined) {
-				await context.globalState.update("planModeRequestyModelInfo", requestyModelInfo)
-				await context.globalState.update("actModeRequestyModelInfo", requestyModelInfo)
-			}
-			if (togetherModelId !== undefined) {
-				await context.globalState.update("planModeTogetherModelId", togetherModelId)
-				await context.globalState.update("actModeTogetherModelId", togetherModelId)
-			}
-			if (fireworksModelId !== undefined) {
-				await context.globalState.update("planModeFireworksModelId", fireworksModelId)
-				await context.globalState.update("actModeFireworksModelId", fireworksModelId)
-			}
-			if (sapAiCoreModelId !== undefined) {
-				await context.globalState.update("planModeSapAiCoreModelId", sapAiCoreModelId)
-				await context.globalState.update("actModeSapAiCoreModelId", sapAiCoreModelId)
-			}
-			if (groqModelId !== undefined) {
-				await context.globalState.update("planModeGroqModelId", groqModelId)
-				await context.globalState.update("actModeGroqModelId", groqModelId)
-			}
-			if (groqModelInfo !== undefined) {
-				await context.globalState.update("planModeGroqModelInfo", groqModelInfo)
-				await context.globalState.update("actModeGroqModelInfo", groqModelInfo)
-			}
-			if (huggingFaceModelId !== undefined) {
-				await context.globalState.update("planModeHuggingFaceModelId", huggingFaceModelId)
-				await context.globalState.update("actModeHuggingFaceModelId", huggingFaceModelId)
-			}
-			if (huggingFaceModelInfo !== undefined) {
-				await context.globalState.update("planModeHuggingFaceModelInfo", huggingFaceModelInfo)
-				await context.globalState.update("actModeHuggingFaceModelInfo", huggingFaceModelInfo)
-			}
-		} else {
-			console.log("Migrating with separate models ENABLED - using current->plan, previous->act")
+		console.log(`[Migration] Found ${oldTaskHistory.length} tasks in old format`)
 
-			// Use current values for plan mode
-			if (apiProvider !== undefined) {
-				await context.globalState.update("planModeApiProvider", apiProvider)
-			}
-			if (apiModelId !== undefined) {
-				await context.globalState.update("planModeApiModelId", apiModelId)
-			}
-			if (thinkingBudgetTokens !== undefined) {
-				await context.globalState.update("planModeThinkingBudgetTokens", thinkingBudgetTokens)
-			}
-			if (reasoningEffort !== undefined) {
-				await context.globalState.update("planModeReasoningEffort", reasoningEffort)
-			}
-			if (vsCodeLmModelSelector !== undefined) {
-				await context.globalState.update("planModeVsCodeLmModelSelector", vsCodeLmModelSelector)
-			}
-			if (awsBedrockCustomSelected !== undefined) {
-				await context.globalState.update("planModeAwsBedrockCustomSelected", awsBedrockCustomSelected)
-			}
-			if (awsBedrockCustomModelBaseId !== undefined) {
-				await context.globalState.update("planModeAwsBedrockCustomModelBaseId", awsBedrockCustomModelBaseId)
-			}
-			if (openRouterModelId !== undefined) {
-				await context.globalState.update("planModeOpenRouterModelId", openRouterModelId)
-			}
-			if (openRouterModelInfo !== undefined) {
-				await context.globalState.update("planModeOpenRouterModelInfo", openRouterModelInfo)
-			}
-			if (openAiModelId !== undefined) {
-				await context.globalState.update("planModeOpenAiModelId", openAiModelId)
-			}
-			if (openAiModelInfo !== undefined) {
-				await context.globalState.update("planModeOpenAiModelInfo", openAiModelInfo)
-			}
-			if (ollamaModelId !== undefined) {
-				await context.globalState.update("planModeOllamaModelId", ollamaModelId)
-			}
-			if (lmStudioModelId !== undefined) {
-				await context.globalState.update("planModeLmStudioModelId", lmStudioModelId)
-			}
-			if (liteLlmModelId !== undefined) {
-				await context.globalState.update("planModeLiteLlmModelId", liteLlmModelId)
-			}
-			if (liteLlmModelInfo !== undefined) {
-				await context.globalState.update("planModeLiteLlmModelInfo", liteLlmModelInfo)
-			}
-			if (requestyModelId !== undefined) {
-				await context.globalState.update("planModeRequestyModelId", requestyModelId)
-			}
-			if (requestyModelInfo !== undefined) {
-				await context.globalState.update("planModeRequestyModelInfo", requestyModelInfo)
-			}
-			if (togetherModelId !== undefined) {
-				await context.globalState.update("planModeTogetherModelId", togetherModelId)
-			}
-			if (fireworksModelId !== undefined) {
-				await context.globalState.update("planModeFireworksModelId", fireworksModelId)
-			}
-			if (sapAiCoreModelId !== undefined) {
-				await context.globalState.update("planModeSapAiCoreModelId", sapAiCoreModelId)
-			}
-			if (groqModelId !== undefined) {
-				await context.globalState.update("planModeGroqModelId", groqModelId)
-			}
-			if (groqModelInfo !== undefined) {
-				await context.globalState.update("planModeGroqModelInfo", groqModelInfo)
-			}
-			if (huggingFaceModelId !== undefined) {
-				await context.globalState.update("planModeHuggingFaceModelId", huggingFaceModelId)
-			}
-			if (huggingFaceModelInfo !== undefined) {
-				await context.globalState.update("planModeHuggingFaceModelInfo", huggingFaceModelInfo)
-			}
+		// Step 2: Create backup
+		console.log("[Migration] Step 2: Creating backup...")
+		const backupPath = await backupTaskHistoryFile()
 
-			// Use previous values for act mode (with fallback to current values)
-			if (previousModeApiProvider !== undefined) {
-				await context.globalState.update("actModeApiProvider", previousModeApiProvider)
-			} else if (apiProvider !== undefined) {
-				await context.globalState.update("actModeApiProvider", apiProvider)
-			}
-			if (previousModeModelId !== undefined) {
-				await context.globalState.update("actModeApiModelId", previousModeModelId)
-			} else if (apiModelId !== undefined) {
-				await context.globalState.update("actModeApiModelId", apiModelId)
-			}
-			if (previousModeThinkingBudgetTokens !== undefined) {
-				await context.globalState.update("actModeThinkingBudgetTokens", previousModeThinkingBudgetTokens)
-			} else if (thinkingBudgetTokens !== undefined) {
-				await context.globalState.update("actModeThinkingBudgetTokens", thinkingBudgetTokens)
-			}
-			if (previousModeReasoningEffort !== undefined) {
-				await context.globalState.update("actModeReasoningEffort", previousModeReasoningEffort)
-			} else if (reasoningEffort !== undefined) {
-				await context.globalState.update("actModeReasoningEffort", reasoningEffort)
-			}
-			if (previousModeVsCodeLmModelSelector !== undefined) {
-				await context.globalState.update("actModeVsCodeLmModelSelector", previousModeVsCodeLmModelSelector)
-			} else if (vsCodeLmModelSelector !== undefined) {
-				await context.globalState.update("actModeVsCodeLmModelSelector", vsCodeLmModelSelector)
-			}
-			if (previousModeAwsBedrockCustomSelected !== undefined) {
-				await context.globalState.update("actModeAwsBedrockCustomSelected", previousModeAwsBedrockCustomSelected)
-			} else if (awsBedrockCustomSelected !== undefined) {
-				await context.globalState.update("actModeAwsBedrockCustomSelected", awsBedrockCustomSelected)
-			}
-			if (previousModeAwsBedrockCustomModelBaseId !== undefined) {
-				await context.globalState.update("actModeAwsBedrockCustomModelBaseId", previousModeAwsBedrockCustomModelBaseId)
-			} else if (awsBedrockCustomModelBaseId !== undefined) {
-				await context.globalState.update("actModeAwsBedrockCustomModelBaseId", awsBedrockCustomModelBaseId)
-			}
-			if (previousModeSapAiCoreModelId !== undefined) {
-				await context.globalState.update("actModeSapAiCoreModelId", previousModeSapAiCoreModelId)
-			} else if (sapAiCoreModelId !== undefined) {
-				await context.globalState.update("actModeSapAiCoreModelId", sapAiCoreModelId)
-			}
+		if (!backupPath) {
+			console.warn("[Migration] Failed to create backup, but continuing with migration")
+			console.warn("[Migration] Original file will be preserved in place")
+		}
 
-			// For fields without previous variants, use current values for act mode
-			if (previousModeModelInfo !== undefined) {
-				await context.globalState.update("actModeOpenRouterModelInfo", previousModeModelInfo)
-			} else if (openRouterModelInfo !== undefined) {
-				await context.globalState.update("actModeOpenRouterModelInfo", openRouterModelInfo)
-			}
-			if (openRouterModelId !== undefined) {
-				await context.globalState.update("actModeOpenRouterModelId", openRouterModelId)
-			}
-			if (openAiModelId !== undefined) {
-				await context.globalState.update("actModeOpenAiModelId", openAiModelId)
-			}
-			if (openAiModelInfo !== undefined) {
-				await context.globalState.update("actModeOpenAiModelInfo", openAiModelInfo)
-			}
-			if (ollamaModelId !== undefined) {
-				await context.globalState.update("actModeOllamaModelId", ollamaModelId)
-			}
-			if (lmStudioModelId !== undefined) {
-				await context.globalState.update("actModeLmStudioModelId", lmStudioModelId)
-			}
-			if (liteLlmModelId !== undefined) {
-				await context.globalState.update("actModeLiteLlmModelId", liteLlmModelId)
-			}
-			if (liteLlmModelInfo !== undefined) {
-				await context.globalState.update("actModeLiteLlmModelInfo", liteLlmModelInfo)
-			}
-			if (requestyModelId !== undefined) {
-				await context.globalState.update("actModeRequestyModelId", requestyModelId)
-			}
-			if (requestyModelInfo !== undefined) {
-				await context.globalState.update("actModeRequestyModelInfo", requestyModelInfo)
-			}
-			if (togetherModelId !== undefined) {
-				await context.globalState.update("actModeTogetherModelId", togetherModelId)
-			}
-			if (fireworksModelId !== undefined) {
-				await context.globalState.update("actModeFireworksModelId", fireworksModelId)
-			}
-			if (groqModelId !== undefined) {
-				await context.globalState.update("actModeGroqModelId", groqModelId)
-			}
-			if (groqModelInfo !== undefined) {
-				await context.globalState.update("actModeGroqModelInfo", groqModelInfo)
-			}
-			if (huggingFaceModelId !== undefined) {
-				await context.globalState.update("actModeHuggingFaceModelId", huggingFaceModelId)
-			}
-			if (huggingFaceModelInfo !== undefined) {
-				await context.globalState.update("actModeHuggingFaceModelInfo", huggingFaceModelInfo)
+		// Step 3: Read current workspace state
+		console.log("[Migration] Step 3: Reading current workspace state...")
+		const currentWorkspaceHistory = context.workspaceState.get<HistoryItem[]>("taskHistory", [])
+		console.log(`[Migration] Current workspace has ${currentWorkspaceHistory.length} tasks`)
+
+		// Step 4: Merge data
+		console.log("[Migration] Step 4: Merging task histories...")
+		const mergedHistory = [...currentWorkspaceHistory]
+		const existingIds = new Set(currentWorkspaceHistory.map((item) => item.id))
+		let addedCount = 0
+
+		for (const item of oldTaskHistory) {
+			if (!existingIds.has(item.id)) {
+				mergedHistory.push(item)
+				addedCount++
 			}
 		}
 
-		// Clean up legacy keys after successful migration
-		console.log("Cleaning up legacy keys...")
-		await context.globalState.update("apiProvider", undefined)
-		await context.globalState.update("apiModelId", undefined)
-		await context.globalState.update("thinkingBudgetTokens", undefined)
-		await context.globalState.update("reasoningEffort", undefined)
-		await context.globalState.update("vsCodeLmModelSelector", undefined)
-		await context.globalState.update("awsBedrockCustomSelected", undefined)
-		await context.globalState.update("awsBedrockCustomModelBaseId", undefined)
-		await context.globalState.update("openRouterModelId", undefined)
-		await context.globalState.update("openRouterModelInfo", undefined)
-		await context.globalState.update("openAiModelId", undefined)
-		await context.globalState.update("openAiModelInfo", undefined)
-		await context.globalState.update("ollamaModelId", undefined)
-		await context.globalState.update("lmStudioModelId", undefined)
-		await context.globalState.update("liteLlmModelId", undefined)
-		await context.globalState.update("liteLlmModelInfo", undefined)
-		await context.globalState.update("requestyModelId", undefined)
-		await context.globalState.update("requestyModelInfo", undefined)
-		await context.globalState.update("togetherModelId", undefined)
-		await context.globalState.update("fireworksModelId", undefined)
-		await context.globalState.update("sapAiCoreModelId", undefined)
-		await context.globalState.update("groqModelId", undefined)
-		await context.globalState.update("groqModelInfo", undefined)
-		await context.globalState.update("huggingFaceModelId", undefined)
-		await context.globalState.update("huggingFaceModelInfo", undefined)
-		await context.globalState.update("previousModeApiProvider", undefined)
-		await context.globalState.update("previousModeModelId", undefined)
-		await context.globalState.update("previousModeModelInfo", undefined)
-		await context.globalState.update("previousModeVsCodeLmModelSelector", undefined)
-		await context.globalState.update("previousModeThinkingBudgetTokens", undefined)
-		await context.globalState.update("previousModeReasoningEffort", undefined)
-		await context.globalState.update("previousModeAwsBedrockCustomSelected", undefined)
-		await context.globalState.update("previousModeAwsBedrockCustomModelBaseId", undefined)
-		await context.globalState.update("previousModeSapAiCoreModelId", undefined)
-
-		console.log("Successfully migrated legacy API configuration to mode-specific keys")
-	} catch (error) {
-		console.error("Failed to migrate legacy API configuration to mode-specific keys:", error)
-		// Continue execution - migration failure shouldn't break extension startup
-	}
-}
-
-export async function migrateWelcomeViewCompleted(context: vscode.ExtensionContext) {
-	try {
-		// Check if welcomeViewCompleted is already set
-		const welcomeViewCompleted = context.globalState.get("welcomeViewCompleted")
-
-		if (welcomeViewCompleted === undefined) {
-			console.log("Migrating welcomeViewCompleted setting...")
-
-			// Fetch API keys directly from secrets
-			const apiKey = await context.secrets.get("apiKey")
-			const openRouterApiKey = await context.secrets.get("openRouterApiKey")
-			const clineAccountId = await context.secrets.get("clineAccountId")
-			const openAiApiKey = await context.secrets.get("openAiApiKey")
-			const ollamaApiKey = await context.secrets.get("ollamaApiKey")
-			const liteLlmApiKey = await context.secrets.get("liteLlmApiKey")
-			const geminiApiKey = await context.secrets.get("geminiApiKey")
-			const openAiNativeApiKey = await context.secrets.get("openAiNativeApiKey")
-			const deepSeekApiKey = await context.secrets.get("deepSeekApiKey")
-			const requestyApiKey = await context.secrets.get("requestyApiKey")
-			const togetherApiKey = await context.secrets.get("togetherApiKey")
-			const qwenApiKey = await context.secrets.get("qwenApiKey")
-			const doubaoApiKey = await context.secrets.get("doubaoApiKey")
-			const mistralApiKey = await context.secrets.get("mistralApiKey")
-			const asksageApiKey = await context.secrets.get("asksageApiKey")
-			const xaiApiKey = await context.secrets.get("xaiApiKey")
-			const sambanovaApiKey = await context.secrets.get("sambanovaApiKey")
-			const sapAiCoreClientId = await context.secrets.get("sapAiCoreClientId")
-			const difyApiKey = await context.secrets.get("difyApiKey")
-
-			// Fetch configuration values from global state
-			const awsRegion = context.globalState.get("awsRegion")
-			const vertexProjectId = context.globalState.get("vertexProjectId")
-			const planModeOllamaModelId = context.globalState.get("planModeOllamaModelId")
-			const planModeLmStudioModelId = context.globalState.get("planModeLmStudioModelId")
-			const actModeOllamaModelId = context.globalState.get("actModeOllamaModelId")
-			const actModeLmStudioModelId = context.globalState.get("actModeLmStudioModelId")
-			const planModeVsCodeLmModelSelector = context.globalState.get("planModeVsCodeLmModelSelector")
-			const actModeVsCodeLmModelSelector = context.globalState.get("actModeVsCodeLmModelSelector")
-
-			// This is the original logic used for checking if the welcome view should be shown
-			// It was located in the ExtensionStateContextProvider
-			const hasKey = [
-				apiKey,
-				openRouterApiKey,
-				awsRegion,
-				vertexProjectId,
-				openAiApiKey,
-				ollamaApiKey,
-				planModeOllamaModelId,
-				planModeLmStudioModelId,
-				actModeOllamaModelId,
-				actModeLmStudioModelId,
-				liteLlmApiKey,
-				geminiApiKey,
-				openAiNativeApiKey,
-				deepSeekApiKey,
-				requestyApiKey,
-				togetherApiKey,
-				qwenApiKey,
-				doubaoApiKey,
-				mistralApiKey,
-				planModeVsCodeLmModelSelector,
-				actModeVsCodeLmModelSelector,
-				clineAccountId,
-				asksageApiKey,
-				xaiApiKey,
-				sambanovaApiKey,
-				sapAiCoreClientId,
-				difyApiKey,
-			].some((key) => key !== undefined)
-
-			// Set welcomeViewCompleted based on whether user has keys
-			await context.globalState.update("welcomeViewCompleted", hasKey)
-
-			console.log(`Migration: Set welcomeViewCompleted to ${hasKey} based on existing API keys`)
+		console.log(`[Migration] Added ${addedCount} new tasks from global history`)
+		console.log(`[Migration] Total tasks after merge: ${mergedHistory.length}`)
+
+		// Sort by timestamp (most recent first)
+		mergedHistory.sort((a, b) => b.ts - a.ts)
+
+		// Step 5: Write to workspace state
+		console.log("[Migration] Step 5: Writing to workspace state...")
+		await context.workspaceState.update("taskHistory", mergedHistory)
+		console.log("[Migration] Successfully wrote to workspace state")
+
+		// Step 6: Mark migration as complete
+		console.log("[Migration] Step 6: Marking migration as complete...")
+		await context.globalState.update(MIGRATION_VERSION_KEY, CURRENT_MIGRATION_VERSION)
+
+		console.log("[Migration] ✅ Migration completed successfully!")
+		console.log("[Migration] Summary:")
+		console.log(`[Migration]   - Old global tasks: ${oldTaskHistory.length}`)
+		console.log(`[Migration]   - Workspace tasks: ${currentWorkspaceHistory.length}`)
+		console.log(`[Migration]   - Tasks added: ${addedCount}`)
+		console.log(`[Migration]   - Total after merge: ${mergedHistory.length}`)
+		if (backupPath) {
+			console.log(`[Migration]   - Backup created: ${path.basename(backupPath)}`)
 		}
+		console.log("[Migration]   - Original file preserved for rollback")
 	} catch (error) {
-		console.error("Failed to migrate welcomeViewCompleted:", error)
-		// Continue execution - migration failure shouldn't break extension startup
+		console.error("[Migration] ❌ Migration failed with error:", error)
+		console.error("[Migration] Extension will continue with current state")
+		console.error("[Migration] If you see this error repeatedly, please report it as a bug")
+		console.error("[Migration] Your data is safe - original files are preserved")
+		// Don't throw - allow extension to continue
+		// Don't mark as migrated so we can try again on next activation
 	}
 }
+
+/**
+ * Export validation function for testing
+ */
+export { validateTaskHistory }
diff --git a/src/core/storage/utils/state-helpers.ts b/src/core/storage/utils/state-helpers.ts
index e5d5f228e..3649afce3 100644
--- a/src/core/storage/utils/state-helpers.ts
+++ b/src/core/storage/utils/state-helpers.ts
@@ -137,6 +137,7 @@ export async function readWorkspaceStateFromDisk(context: ExtensionContext): Pro
 	const localWorkflowToggles = context.workspaceState.get("workflowToggles") as ClineRulesToggles | undefined
 
 	return {
+		taskHistory: [], // Initialize empty, will be populated from workspace state
 		localClineRulesToggles: localClineRulesToggles || {},
 		localWindsurfRulesToggles: localWindsurfRulesToggles || {},
 		localCursorRulesToggles: localCursorRulesToggles || {},
@@ -536,7 +537,6 @@ export async function readGlobalStateFromDisk(context: ExtensionContext): Promis
 			isNewUser: isNewUser ?? true,
 			welcomeViewCompleted,
 			lastShownAnnouncementId,
-			taskHistory: taskHistory || [],
 			autoApprovalSettings: autoApprovalSettings || DEFAULT_AUTO_APPROVAL_SETTINGS, // default value can be 0 or empty string
 			globalClineRulesToggles: globalClineRulesToggles || {},
 			browserSettings: { ...DEFAULT_BROWSER_SETTINGS, ...browserSettings }, // this will ensure that older versions of browserSettings (e.g. before remoteBrowserEnabled was added) are merged with the default values (false for remoteBrowserEnabled)
diff --git a/src/extension.ts b/src/extension.ts
index 47b05cf98..0e4d62126 100644
--- a/src/extension.ts
+++ b/src/extension.ts
@@ -27,6 +27,7 @@ import { fixWithCline } from "./core/controller/commands/fixWithCline"
 import { improveWithCline } from "./core/controller/commands/improveWithCline"
 import { sendAddToInputEvent } from "./core/controller/ui/subscribeToAddToInput"
 import { sendFocusChatInputEvent } from "./core/controller/ui/subscribeToFocusChatInput"
+import { migrateTaskHistoryToWorkspaceState } from "./core/storage/state-migrations"
 import { workspaceResolver } from "./core/workspace"
 import { focusChatInput, getContextForCommand } from "./hosts/vscode/commandUtils"
 import { abortCommitGeneration, generateCommitMessage } from "./hosts/vscode/commit-message-generator"
@@ -52,6 +53,9 @@ https://github.com/microsoft/vscode-webview-ui-toolkit-samples/tree/main/framewo
 export async function activate(context: vscode.ExtensionContext) {
 	setupHostProvider(context)
 
+	// Run migration before initializing StateManager
+	await migrateTaskHistoryToWorkspaceState(context)
+
 	const webview = (await initialize(context)) as VscodeWebviewProvider
 
 	Logger.log("Cline extension activated")
diff --git a/src/services/mcp/McpHub.ts b/src/services/mcp/McpHub.ts
index 2b51b7ef2..db3b2e677 100644
--- a/src/services/mcp/McpHub.ts
+++ b/src/services/mcp/McpHub.ts
@@ -872,7 +872,7 @@ export class McpHub {
 
 			return {
 				...result,
-				content: result.content ?? [],
+				content: (result.content ?? []) as McpToolCallResponse["content"],
 			}
 		} catch (error) {
 			this.telemetryService.captureMcpToolCall(
